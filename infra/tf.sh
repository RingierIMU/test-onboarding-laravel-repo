#!/usr/bin/env bash

# ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ #
# ðŸ’¥                                                            ðŸ’¥ #
# ðŸ’¥ Do not edit this file as it will be overwritten!           ðŸ’¥ #
# ðŸ’¥                                                            ðŸ’¥ #
# ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ ðŸ’¥ #

readlink_bin="${READLINK_PATH:-readlink}"
if ! "${readlink_bin}" -f test &>/dev/null; then
  __DIR__="$(dirname "$(python3 -c "import os,sys; print(os.path.realpath(os.path.expanduser(sys.argv[1])))" "${0}")")"
else
  __DIR__="$(dirname "$("${readlink_bin}" -f "${0}")")"
fi

source "${__DIR__}/.bash/functions.lib.sh"

set -E
trap 'throw_exception' ERR

cd "${__DIR__}"

# config
kube_env_file="${__DIR__}/.kube-env"
terraform_version="$(<${__DIR__}/.terraform-version)"
aws_profile="rimu"

# envwars
export TF_IN_AUTOMATION="true"

requires_env() {
  if [[ -z "${ENV}" ]]; then
    consolelog "please set ENV" "error"
    exit 1
  fi
}

check_target() {
  local target
  target="${1}"

  if [[ "${target}" == "plan" ]]; then
    if [[ "${JENKINS_CI}" == "true" ]]; then
      # parallelism: 10 => 15
      export TERRAFORM_PARALLELISM=15
      # rps 4 => 7
      export CLOUDFLARE_RPS=7
      # retries 3 => 50
      export CLOUDFLARE_RETRIES=50
      # min_backoff 1 => 1
      export CLOUDFLARE_MIN_BACKOFF=1
      # max_backoff 30 => 60
      export CLOUDFLARE_MAX_BACKOFF=60
    fi
  fi

  if file_exists "${kube_env_file}"; then
    if [[ "${JENKINS_CI}" == "true" ]]; then
      lock_or_wait "kube_context_switch.lock" # only required when deploying to multiple eks clusters via jenkins
    fi

    if [[ "${target}" == "init" ]]; then
      "${__DIR__}/kube.sh" init
      consolelog "initialised kube context" "success"
    fi
  fi
}

check_whoami() {
  if [[ "${JENKINS_CI}" != "true" ]] && [[ "$(id -u)" == "0" ]]; then
    consolelog "do not run as root" "error"
    exit 1
  fi
}

install_terraform() {
  local kernel_name arch zip_file target_bin
  if ! terraform --version | grep -qF "Terraform v${terraform_version}"; then
    consolelog "Installing terraform v${terraform_version}..."
    kernel_name="$(uname -s | tr '[:upper:]' '[:lower:]')"
    arch="$(current_arch)"

    zip_file="terraform_${terraform_version}_${kernel_name}_${arch}.zip"

    curl -#LO "https://releases.hashicorp.com/terraform/${terraform_version}/${zip_file}"

    target_bin="/usr/local/bin/terraform"
    if [[ ! -w "${target_bin:?}" ]]; then
      sudo touch "${target_bin:?}"
      sudo chown "${USER}" "${target_bin:?}"
    fi

    unzip -qjop "${zip_file}" "terraform" >"${target_bin:?}"
    chmod +x "${target_bin:?}"
    rm -f "${zip_file}"
  else
    consolelog "Found terraform v${terraform_version}" success
  fi
}

check_terraform() {
  # --version flag available on gawk
  if ! awk --version >/dev/null; then
    consolelog "gawk is not installed" error
    throw_exception
  fi

  # prefer tfenv method
  if command -v tfenv >/dev/null && ! tfenv list | awk '/'"${terraform_version}"'/' | grep . >/dev/null; then
    consolelog "Using tfenv" success
    lock_or_wait "check_terraform.lock"
    if ! tfenv list | awk '/'"${terraform_version}"'/' | grep . >/dev/null; then
      tfenv install "${terraform_version}"
    else
      consolelog "Found terraform v${terraform_version}" success
    fi
    return 0
  fi
  # fallback to native install
  if ! command -v terraform >/dev/null || ! terraform --version | grep -qF "Terraform v${terraform_version}"; then
    consolelog "Using native terraform" success
    lock_or_wait "check_terraform.lock"
    install_terraform
  fi
}

check_provider_aws() {
  if ! command -v aws >/dev/null; then
    sudo -H pip3 install awscli -U
  fi

  if ! aws --profile "${aws_profile}" configure list >/dev/null; then
    aws --profile "${aws_profile}" configure
  fi
}

check_terraecs() {
  if ! command -v terraecs >/dev/null; then
    sudo -H pip3 install terraecs -U
  fi
}

target_upgrade() {
  local git_repo="${1:-git@github.com:RingierIMU/tf-common.git}" git_branch="${2:-master}"

  local change_profile=0 change_cloudflare=0 change_ns_zone=0 change_region=0
  local region default_region ns_zone_new default_ns_zone ns_zone_id_new default_ns_zone_id maintenance_window default_maintenance_window
  local email default_email api_key default_api_key
  consolelog "Using git branch: ${git_branch} from: ${git_repo}"
  git clone --branch "${git_branch}" --single-branch "${git_repo}" tmp_common

  consolelog "copying latest .dot file libs before using get_value..."
  cp -fr tmp_common/.bash ./
  cp -fr tmp_common/.python ./

  if [ -f _providers.tf ]; then
    if grep jenkins_instance_role _providers.tf; then
      change_profile=1
    fi
    if grep -E 'cloudflare_email_(group|sports)' _providers.tf; then
      change_cloudflare=1
    fi
  fi

  if [ -f _variables.tf ]; then
    if grep "imobiliare.ro" _variables.tf; then
      consolelog "imobiliare.ro change detected"
      region=$(get_variable_default "region" <_variables.tf)
      ns_zone_new=$(get_variable_default "ns_zone_new" <_variables.tf)
      ns_zone_id_new=$(get_variable_default "ns_zone_id_new" <_variables.tf)
      maintenance_window=$(get_variable_default "maintenance_window" <_variables.tf)
      change_ns_zone=1
    fi
    if grep "eu-central-1" _variables.tf; then
      consolelog "eu-central-1 change detected"
      region=$(get_variable_default "region" <_variables.tf)
      change_region=1
    fi
  fi

  if [[ "${change_cloudflare}" -eq 1 ]]; then
    consolelog "cloudflare change detected"
    email=$(get_cloudflare_value "email" <_providers.tf)
    api_key=$(get_cloudflare_value "api_key" <_providers.tf)
    consolelog "DEBUG: current email=${email}"
  fi

  cp -f tmp_common/*.tf tmp_common/{.gitignore,.terraform-version,.tf-common-version} ./
  cp -f tmp_common/common/*.tfvars ./common/
  cp -f tmp_common/tf.sh tmp_common/kube.sh ./
  rm -rf tmp_common

  if [[ "${change_profile}" -eq 1 ]]; then
    consolelog "Changing the profile back to jenkins_instance_role"
    sed -i.bak "s#id}:role/administrators#id}:role/jenkins_instance_role#g" _providers.tf
    rm -f _providers.tf.bak
  fi
  if [[ "${change_region}" -eq 1 ]]; then
    default_region=$(get_variable_default "region" <_variables.tf)
    if [[ ! -z ${default_region} ]] && [[ ! -z ${region} ]]; then
      consolelog "Changing the region back to ${region} from ${default_region}"
      sed -i.bak "s#${default_region}#${region}#g" _variables.tf
      rm -f _variables.tf.bak
    else
      consolelog "Either region: ${region} or default_region: ${default_region} empty" error
      throw_exception
    fi
  fi
  if [[ "${change_cloudflare}" -eq 1 ]]; then
    default_email=$(get_cloudflare_value "email" <_providers.tf)
    default_api_key=$(get_cloudflare_value "api_key" <_providers.tf)
    if [[ ! -z ${default_email} ]] && [[ ! -z ${email} ]]; then
      consolelog "Changing the email back to ${email} from ${default_email}"
      sed -i.bak "s#${default_email}#${email}#g" _providers.tf
      rm -f _providers.tf.bak
    else
      consolelog "Either email: ${email} or default_email: ${default_email} empty" error
      throw_exception
    fi
    if [[ ! -z ${default_api_key} ]] && [[ ! -z ${api_key} ]]; then
      consolelog "Changing the api_key back to ${api_key} from ${default_api_key}"
      sed -i.bak "s#${default_api_key}#${api_key}#g" _providers.tf
      rm -f _providers.tf.bak
    else
      consolelog "Either api_key: ${api_key} or default_api_key: ${default_api_key} empty" error
      throw_exception
    fi
  fi
  if [[ "${change_ns_zone}" -eq 1 ]]; then
    default_region=$(get_variable_default "region" <_variables.tf)
    default_ns_zone=$(get_variable_default "ns_zone_new" <_variables.tf)
    default_ns_zone_id=$(get_variable_default "ns_zone_id_new" <_variables.tf)
    default_maintenance_window=$(get_variable_default "maintenance_window" <_variables.tf)
    if [[ ! -z ${default_region} ]] && [[ ! -z ${region} ]]; then
      consolelog "Changing the region back to ${region} from ${default_region}"
      sed -i.bak "s#${default_region}#${region}#g" _variables.tf
      rm -f _variables.tf.bak
    else
      consolelog "Either region: ${region} or default_region: ${default_region} empty" error
      throw_exception
    fi
    if [[ ! -z ${default_ns_zone} ]] && [[ ! -z ${ns_zone_new} ]]; then
      consolelog "Changing the ns_zone_new back to ${ns_zone_new} from ${default_ns_zone}"
      sed -i.bak "s#${default_ns_zone}#${ns_zone_new}#g" _variables.tf
      rm -f _variables.tf.bak
    else
      consolelog "Either ns_zone_new: ${ns_zone_new} or default_ns_zone: ${default_ns_zone} empty" error
      throw_exception
    fi
    if [[ ! -z ${default_ns_zone} ]] && [[ ! -z ${ns_zone_id_new} ]]; then
      consolelog "Change the ns_zone_id_new back to ${ns_zone_id_new} from ${default_ns_zone_id}"
      sed -i.bak "s#${default_ns_zone_id}#${ns_zone_id_new}#g" _variables.tf
      rm -f _variables.tf.bak
    else
      consolelog "Either ns_zone_id_new: ${ns_zone_id_new} or default_ns_zone: ${default_ns_zone} empty" error
      throw_exception
    fi
    if [[ ! -z ${default_maintenance_window} ]] && [[ ! -z ${maintenance_window} ]]; then
      consolelog "Change the maintenance_window back to ${maintenance_window} from ${default_maintenance_window}"
      sed -i.bak "s#${default_maintenance_window}#${maintenance_window}#g" _variables.tf
      rm -f _variables.tf.bak
    else
      consolelog "Either maintenance_window: ${maintenance_window} or default_maintenance_window: ${default_maintenance_window} empty" error
      throw_exception
    fi
  fi

  # Ensure updates are formatted
  terraform fmt -recursive

  exit 0
}

target_base() {
  git clone git@github.com:RingierIMU/tf-base.git tmp_base
  cp -f tmp_base/*.tf ./
  cp -f tmp_base/Jenkinsfile.sample ./Jenkinsfile
  rm -rf tmp_base
}

target_env() {
  if [[ -z "${APP_NAME}" ]] || [[ -z "${PREFIX}" ]]; then
    consolelog "please set APP_NAME and PREFIX" "error"
    exit 1
  fi

  git clone git@github.com:RingierIMU/tf-env.git tmp_env
  cp -f tmp_env/*.tf ./
  cp -f tmp_env/Jenkinsfile.sample ./Jenkinsfile

  sed "s/PREFIX/${PREFIX}/g" tmp_env/_remotes.tf.sample >_remotes.tf
  sed "s/APP_NAME/${APP_NAME}/g" tmp_env/variables.tf.sample >variables.tf

  rm -rf tmp_env
}

target_create() {
  if [[ -z "${APP_NAME}" ]] || [[ -z "${PREFIX}" ]]; then
    consolelog "please set APP_NAME, PREFIX and PREFIX_SHORT" "error"
    exit 1
  fi

  sed "s/APP_NAME/${APP_NAME}/g" _backend.tf.sample >_backend.tf

  sed -i.bak "s/PREFIX_SHORT/${PREFIX_SHORT}/g" _backend.tf
  rm -f _backend.tf.bak
  sed -i.bak "s/PREFIX/${PREFIX}/g" _backend.tf
  rm -f _backend.tf.bak

  TF_PID="$(mktemp)" target_init

  rm _backend.tf.sample

  mkdir -p app
  for workspace in "${@}"; do
    if ! terraform workspace select "${workspace}" 2>/dev/null; then
      terraform workspace new "${workspace}"
      touch "app/${workspace}.tfvars"
    fi
  done

  if [[ "${__DIR__}" == *"/infra" ]]; then
    rm -rf .git
  fi
}

target_init() {
  terraform init -upgrade=true &

  echo $! >"${TF_PID:?}"
  watcher $$ &
  wait "$(<"${TF_PID:?}")"
}

target_validate() {
  requires_env

  terraform get
  terraform workspace select "${ENV}"
  terraform fmt -list
  terraform validate
}

target_plan() {
  requires_env

  terraform get
  terraform workspace select "${ENV}"

  (
    set -o pipefail
    consolelog "running terraform plan"
    terraform plan "${@}" \
      -parallelism=${TERRAFORM_PARALLELISM:-10} \
      -lock=${TERRAFORM_LOCK:-true} \
      -lock-timeout=${TERRAFORM_LOCK_TIMEOUT:-600s} \
      -var-file="common/${ENV}.tfvars" \
      -var-file="app/${ENV}.tfvars" \
      -out "${ENV}.plan" 2>&1 | tee "${ENV}.output"

    echo ${PIPESTATUS[0]} >"${TF_PID:?}.plan_exit_code"
  ) &

  consolelog "waiting for terraform plan to finish"
  echo $! >"${TF_PID:?}"
  local plan_pid
  plan_pid="$(<"${TF_PID:?}")"
  watcher $$ &
  wait "${plan_pid}"

  consolelog "terraform plan finished"
  local plan_exit_code
  plan_exit_code=$(<"${TF_PID:?}.plan_exit_code")
  if [[ "${plan_exit_code}" -ne 0 ]]; then
    consolelog "terraform plan failed with exit_code ${plan_exit_code}" "error"
    exit 1
  fi
  consolelog "terraform plan plan_exit_code: ${plan_exit_code}"
  rm -f "${TF_PID:?}.plan_exit_code"
  exit "${plan_exit_code}"
}

target_target() {
  requires_env

  terraform get
  terraform workspace select "${ENV}"
  terraform plan -target "${@}" \
    -lock-timeout=600s \
    -var-file="common/${ENV}.tfvars" \
    -var-file="app/${ENV}.tfvars" \
    -out "${ENV}.plan"
}

target_show() {
  requires_env

  terraform workspace select "${ENV}"
  terraform show "${ENV}.plan"
}

target_apply() {
  requires_env

  terraform workspace select "${ENV}"
  terraform show "${ENV}.plan"
  terraform apply "${@}" \
    -parallelism=${TERRAFORM_PARALLELISM:-10} \
    -lock-timeout=600s \
    "${ENV}.plan" &

  echo $! >"${TF_PID:?}"
  watcher $$ &
  wait "$(<"${TF_PID:?}")"

  rm "${ENV}.plan"
  rm -f "${ENV}.output"
}

target_destroy() {
  requires_env

  terraform workspace select "${ENV}"
  terraform destroy \
    -var-file="common/${ENV}.tfvars" \
    -var-file="app/${ENV}.tfvars"
}

target_state() {
  requires_env

  terraform get
  terraform workspace select "${ENV}"
  terraform state "${@}"
}

target_import() {
  requires_env

  terraform workspace select "${ENV}"
  terraform import \
    -var-file="common/${ENV}.tfvars" \
    -var-file="app/${ENV}.tfvars" \
    "${@}"
}

target_console() {
  requires_env

  terraform get
  terraform workspace select "${ENV}"
  terraform console \
    -var-file="common/${ENV}.tfvars" \
    -var-file="app/${ENV}.tfvars"
}

target_unlock() {
  requires_env

  terraform get
  terraform workspace select "${ENV}"
  terraform force-unlock \
    "${@}"
}

target_runcmd() {
  requires_env
  check_terraecs

  if [[ -z "${REPO_NAME}" ]]; then
    REPO_NAME="$(basename "$PWD")"
    if [[ "${REPO_NAME}" == "infra" ]]; then
      REPO_NAME="$(basename "${PWD%/*}")"
    fi
  fi

  terraform workspace select "${ENV}"
  terraform output "${REPO_NAME//-/_}_cli_ecs_task" -json >output.json

  AWS_PROFILE="${aws_profile}" terraecs -f output.json run "${@}"
}

run_hook() {
  local when what filename filepath
  when="${1}"
  what="${2}"
  filename=".${when}-${what}"
  filepath="${__DIR__}/${filename}"

  if [[ -f "${filepath}" ]]; then
    consolelog "running ${filename} script" "success"
    "${filepath}"
  fi
}

check_whoami
check_terraform

# we can assume that jenkins is properly configured...
if [[ -z "${JENKINS_CI}" ]] || [[ "${JENKINS_CI}" != "true" ]]; then
  check_provider_aws
fi

target="target_${1}"
if [[ "$(type -t "${target}")" != "function" ]]; then
  consolelog "unknown target: ${target#*_}" "error"

  echo -e "\n\nAvailable targets:"
  targets=($(compgen -A function))
  for target in "${targets[@]}"; do
    if [[ "${target}" == "target_"* ]]; then
      echo "- ${target#*_}"
    fi
  done

  exit 1
fi

check_target "${target#*_}"
shift

if [[ "${target#*_}" =~ init|plan|apply ]]; then
  trap 'touch /tmp/tf_cleanup_lock; kill -s SIGTERM $(<$TF_PID); rm -rf $TF_PID' TERM INT

  run_hook pre "${target#*_}"

  TF_PID="$(mktemp)" "${target}" "${@}"

  run_hook post "${target#*_}"
else
  "${target}" "${@}"
fi
